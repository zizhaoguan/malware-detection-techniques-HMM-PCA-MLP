// Malware Detection HMM.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <fstream>
#include <String>
#include "HmmModel.h"
#include "windows.h"

using namespace std;

bool translateOpcode(int&, const char*);
double computeLog(int , HmmModel* );
HmmModel* training(int*, int&, string, string);
HmmModel* scoring(HmmModel*, int*, int& );
bool translateOpcode2(int&, const char*);
bool translateOpcode3(int&, const char*);



enum Opcode {JZ, JNZ, JB, JNB, JE, JNE, JS, JNS, JC, JNC, JA, JNA, JAE, JG, JNG, JGE, JNGE, JBE, JNBE, JL, 
JNL, JLE, JNLE, JP, JNP, JPE, JNPO, JMP, REP, MOV, POP, ADD, RETN, PUSH, RCL, CALL, POPA, LEA, DIV, CLD, ADC, SHL, 
ROR, INC, OR, TEST, SHR, SBB, BOUND, SUB, XOR, PUSHA, DEC, AND, FIDIV, NOT, NEG, IMUL, MOVSB, LOOP, INS, 
STD, CMP, MOVZX, START, ENTER, POPF, RETF, SAR, XCHG, AAM, PAND};

int main()
{
	int* trainingOpcodePointer=NULL;
	cout << "outside: " << trainingOpcodePointer<<endl;
	int countTrainingOpcode;

	int numOfModel;
	cout << "how many training models do you want to generate?\n";
	cin >> numOfModel;
	HmmModel** trainingModel = new HmmModel * [numOfModel];
	
	string inFileName;
	cout << "Name of training set?\n";
	cin >> inFileName;

	string outFileName;
	cout << "Name of the output file you want?\n";
	cin >> outFileName;

	for (int i = 0; i < numOfModel; i++)
	{
		trainingModel[i] = training(trainingOpcodePointer, countTrainingOpcode, inFileName, outFileName);
	}
	int bestTrainingModel;

	double bestProlog = -1000000;
	//double bestProlog = trainingModel[bestTrainingModel]->getOldProlog();	
	for (int i = 0; i < numOfModel; i++)
	{
		cout << "prolog of [" << i << "] is " << trainingModel[i]->getOldProlog() << endl;
		if (trainingModel[i]->getOldProlog() >= bestProlog)
		{
			bestProlog = trainingModel[i]->getOldProlog();
			bestTrainingModel = i;
		}
	}
	cout << "best model with prolog " << trainingModel[bestTrainingModel]->getOldProlog() << " is model " << bestTrainingModel << endl;
	 
	cout << "The pi, A and B matrix of best model:\n";
	trainingModel[bestTrainingModel]->printPi();
	trainingModel[bestTrainingModel]->printAMatrixWFile(1);
	trainingModel[bestTrainingModel]->printBMatrixWFile(1);
	//cout << "outside again: " << trainingOpcodePointer <<endl;


	cout << "do you want to score? (Y/N)" << endl;
	char choice;
	cin >> choice;
	while (choice == 'Y')
	{
		int* scoringOpcodePointer=NULL;
		int countScoringOpcode;
		
		HmmModel* scoringModel = scoring(trainingModel[bestTrainingModel], scoringOpcodePointer, countScoringOpcode);
		////step of scoring
		//cout << "Name of scoring set?\n";
		//cin >> inFileName;
		//readFile.open(inFileName, ios::in);
		//while (!readFile)
		//{
		//	cout << "wrong file name, tell me again\n";
		//	cin >> inFileName;
		//	readFile.open(inFileName, ios::in);
		//}

		////create a out put file to store the translate opcode;

		//cout << "Name of the output file you want?\n";
		//cin >> outFileName;
		//checkFile.open(outFileName, ios::in);
		//if (!checkFile)
		//{
		//	writeFile.open(outFileName, ios::out);
		//	while (!writeFile) { cout << "cannot open a new file???"; }
		//}

		//countOpcodeNum = 0; //have the numbers of opcode

		//while (!readFile.eof())
		//{
		//	readFile >> opcodeStr;
		//	if (translateOpcode(aNum, opcodeStr.c_str()))
		//	{
		//		countOpcodeNum++;
		//		writeFile << aNum << '\n';
		//	}
		//	else { cout << "cannot write " << opcodeStr << endl; }
		//}
		//cout << "total opcode: " << countOpcodeNum << endl;
		//readFile.close();
		//writeFile.close();

		////read the output file that contain the integer "opcode", then allocate enough integer space to store it,
		////and let a ptr point to it.
		//readFile.open(outFileName, ios::in);
		//opcodePtr = new int[countOpcodeNum];
		//for (i = 0; i < countOpcodeNum; i++)
		//{
		//	if (!readFile.eof()) { readFile >> opcodePtr[i]; }
		//}
		//readFile.close();
		//checkFile.close();
		//writeFile.close();

		//model->setData(countOpcodeNum);
		//model->computeAlphaPass(opcodePtr);
		//cout << "score: "<<computeLog(model->getT(), model)<<endl;
		//
		////cout << "score: " << model->scoreTestSet(opcodePtr) << endl;
	}
	
	
	

    std::cout << "Done!\n";
}


HmmModel* training(int* opcodePtr, int& countOpcodeNum, string inFileName, string outFileName)
{
	//open the training set file and translate the opcode to integer
	ifstream readFile;
	readFile.open(inFileName, ios::in);
	while (!readFile)
	{
		cout << "wrong file name, tell me again\n";
		cin >> inFileName;
		readFile.open(inFileName, ios::in);
	}

	//create a out put file to store the translate opcode;
	ofstream writeFile;
	
	
	writeFile.open(outFileName, ios::out);
	while (!writeFile)
	{
		cout << "cannot open a new file???" << endl;
		cout << "Name of the output file you want?\n";
		cin >> outFileName;
		writeFile.open(outFileName, ios::out);
	}


	countOpcodeNum = 0;
	int aNum;
	string opcodeStr;
	while (!readFile.eof())
	{
		readFile >> opcodeStr;
		if (translateOpcode2(aNum, opcodeStr.c_str()))
		{
			countOpcodeNum++;
			writeFile << aNum << '\n';
		}
		else { cout << "cannot write " << opcodeStr << endl; }
	}
	cout << "total opcode: " << countOpcodeNum << endl;
	readFile.close();
	writeFile.close();

	//read the output file that contain the integer "opcode", then allocate enough integer space to store it,
	//and let a ptr point to it.
	readFile.open(outFileName, ios::in);
	
	opcodePtr = new int[countOpcodeNum];
	//cout << "inside: " << opcodePtr<<endl;
	int i;
	for (i = 0; i < countOpcodeNum; i++)
	{
		if (!readFile.eof()) { readFile >> opcodePtr[i]; }
	}
	readFile.close();
	//for (i = 0; i < countOpcodeNum; i++) { cout << opcodePtr[i] << endl; }
	HmmModel* model = new HmmModel();
	model->initializeModel(opcodePtr);
	model->printPi();
	model->printAMatrixWFile(0);
	model->printBMatrixWFile(0);
	model->printRowSum();

	model->setData(countOpcodeNum);

	int minIters = 100;
	double err = (double)0.00001;
	while (!(model->checkIfGoodModel()))
	{
		cout << "re-estimate model..." << model->getIter() + 1 << " times\n";
		model->computeAlphaPass(opcodePtr);
		model->computeBetaPass(opcodePtr);
		model->computeGammas(opcodePtr);
		model->reestimate(opcodePtr);

		model->addIter(1);
		model->setNewProlog(computeLog(model->getT(), model));
		cout << "prolog = " << model->getNewProlog() << endl;
		model->setDiff((model->getOldProlog()) - (model->getNewProlog()));
		if (model->getDiff() < 0) { model->setDiff(-(model->getDiff())); }
		if (model->getIter() < minIters || model->getDiff() > err)
		{
			model->setOldProlog(model->getNewProlog());
		}
		else { model->setGoodModel(true); }
	}
	model->printPi();
	model->printAMatrixWFile(0);
	model->printBMatrixWFile(0);
	model->printRowSum();

	return model;
}

HmmModel* scoring(HmmModel* trainingModel, int* opcodePtr, int& countOpcodeNum)
{
	//open the training set file and translate the opcode to integer
	ifstream readFile;
	string inFileName;
	cout << "Name of scoring set?\n";
	cin >> inFileName;
	readFile.open(inFileName, ios::in);
	while (!readFile)
	{
		cout << "wrong file name, tell me again\n";
		cin >> inFileName;
		readFile.open(inFileName, ios::in);
	}

	//create a out put file to store the translate opcode;
	ofstream writeFile;
	
	string outFileName;
	cout << "Name of the output file you want?\n";
	cin >> outFileName;
	writeFile.open(outFileName, ios::out);
	while (!writeFile)
	{ 
		cout << "cannot open a new file???"<<endl;
		cout << "Name of the output file you want?\n";
		cin >> outFileName;
		writeFile.open(outFileName, ios::out);
	}
	

	countOpcodeNum = 0;
	int aNum;
	string opcodeStr;
	while (!readFile.eof())
	{
		readFile >> opcodeStr;
		if (translateOpcode2(aNum, opcodeStr.c_str()))
		{
			countOpcodeNum++;
			writeFile << aNum << '\n';
		}
		else { cout << "cannot write " << opcodeStr << endl; }
	}
	cout << "total opcode: " << countOpcodeNum << endl;
	readFile.close();
	
	writeFile.close();

	//read the output file that contain the integer "opcode", then allocate enough integer space to store it,
	//and let a ptr point to it.
	readFile.open(outFileName, ios::in);
	
	opcodePtr = new int[countOpcodeNum];
	int i;
	for (i = 0; i < countOpcodeNum; i++)
	{
		if (!readFile.eof()) { readFile >> opcodePtr[i]; }
	}
	readFile.close();
	//for (i = 0; i < countOpcodeNum; i++) { cout << opcodePtr[i] << endl; }
	HmmModel* model = new HmmModel();
	model->initializeModel(opcodePtr);
	model->copyPi(trainingModel);
	model->copyA(trainingModel);
	model->copyB(trainingModel);
	//model->BMatrixAddNum(0.00001);
	/*model->printPi();
	model->printAMatrixWFile(0);*/
	model->printBMatrixWFile(0);
	system("pause");
	//start to score
	model->setData(countOpcodeNum);
	//model->checekBadOpCode();
	//model->computeAlphaPass(opcodePtr);

	cout << "score (P(O|¦Ë)): " << model->scoreTestSet(opcodePtr)<<endl;
	cout << "score (per opcode): "<<computeLog(model->getT(), model)/countOpcodeNum<<endl;

	//cout << "score (per opcode): " << computeLog(model->getT(), model) << endl;
	//cout << "score: " << model->scoreTestSet(opcodePtr) << endl;
	/*
	model->printPi();
	model->printAMatrixWFile(0);
	model->printBMatrixWFile(0);
	model->printRowSum();*/

	return model;
}


//convert opcode to integer, if the opcode is wanted return true, else return false
bool translateOpcode(int &aNum, const char* ptr)
{
	//cout << ptr << endl;
	if (strcmp(ptr, "jz") == 0) { aNum = 0; }
	else if (strcmp(ptr, "jnz") == 0) { aNum = 1; }
	else if (strcmp(ptr, "jb") == 0) { aNum = 2; }
	else if (strcmp(ptr, "jnb") == 0) { aNum = 3; }
	else if (strcmp(ptr, "je") == 0) { aNum = 4; }
	else if (strcmp(ptr, "jne") == 0) { aNum = 5; }
	else if (strcmp(ptr, "js") == 0) { aNum = 6; }
	else if (strcmp(ptr, "jns") == 0) { aNum = 7; }
	else if (strcmp(ptr, "jc") == 0) { aNum = 8; }
	else if (strcmp(ptr, "jnc") == 0) { aNum = 9; }
	else if (strcmp(ptr, "ja") == 0) { aNum = 10; }
	else if (strcmp(ptr, "jna") == 0) { aNum = 11; }
	else if (strcmp(ptr, "jae") == 0) { aNum = 12; }
	else if (strcmp(ptr, "jg") == 0) { aNum = 13; }
	else if (strcmp(ptr, "jng") == 0) { aNum = 14; }
	else if (strcmp(ptr, "jge") == 0) { aNum = 15; }
	else if (strcmp(ptr, "jnge") == 0) { aNum = 16; }
	else if (strcmp(ptr, "jbe") == 0) { aNum = 17; }
	else if (strcmp(ptr, "jnbe") == 0) { aNum = 18; }
	else if (strcmp(ptr, "jl") == 0) { aNum = 19; }
	else if (strcmp(ptr, "jnl") == 0) { aNum = 20; }
	else if (strcmp(ptr, "jle") == 0) { aNum = 21; }
	else if (strcmp(ptr, "jnle") == 0) { aNum = 22; }
	else if (strcmp(ptr, "jp") == 0) { aNum = 23; }
	else if (strcmp(ptr, "jnp") == 0) { aNum = 24; }
	else if (strcmp(ptr, "jpe") == 0) { aNum = 25; }
	else if (strcmp(ptr, "jnpo") == 0) { aNum = 26; }
	else if (strcmp(ptr, "jmp") == 0) { aNum = 27; }
	else if (strcmp(ptr, "rep") == 0) { aNum = 28; }
	else if (strcmp(ptr, "mov") == 0) { aNum = 29; }
	else if (strcmp(ptr, "pop") == 0) { aNum = 30; }
	else if (strcmp(ptr, "add") == 0) { aNum = 31; }
	else if (strcmp(ptr, "retn") == 0) { aNum = 32; }
	else if (strcmp(ptr, "push") == 0) { aNum = 33; }
	else if (strcmp(ptr, "rcl") == 0) { aNum = 34; }
	else if (strcmp(ptr, "call") == 0) { aNum = 35; }
	else if (strcmp(ptr, "popa") == 0) { aNum = 36; }
	else if (strcmp(ptr, "lea") == 0) { aNum = 37; }
	else if (strcmp(ptr, "div") == 0) { aNum = 38; }
	else if (strcmp(ptr, "cld") == 0) { aNum = 39; }
	else if (strcmp(ptr, "adc") == 0) { aNum = 40; }
	else if (strcmp(ptr, "shl") == 0) { aNum = 41; }
	else if (strcmp(ptr, "ror") == 0) { aNum = 42; }
	else if (strcmp(ptr, "inc") == 0) { aNum = 43; }
	else if (strcmp(ptr, "or") == 0) { aNum = 44; }
	else if (strcmp(ptr, "test") == 0) { aNum = 45; }
	else if (strcmp(ptr, "shr") == 0) { aNum = 46; }
	else if (strcmp(ptr, "sbb") == 0) { aNum = 47; }
	else if (strcmp(ptr, "bound") == 0) { aNum = 48; }
	else if (strcmp(ptr, "sub") == 0) { aNum = 49; }
	else if (strcmp(ptr, "xor") == 0) { aNum = 50; }
	else if (strcmp(ptr, "pusha") == 0) { aNum = 51; }
	else if (strcmp(ptr, "dec") == 0) { aNum = 52; }
	else if (strcmp(ptr, "and") == 0) { aNum = 53; }
	else if (strcmp(ptr, "fidiv") == 0) { aNum = 54; }
	else if (strcmp(ptr, "not") == 0) { aNum = 55; }
	else if (strcmp(ptr, "neg") == 0) { aNum = 56; }
	else if (strcmp(ptr, "imul") == 0) { aNum = 57; }
	else if (strcmp(ptr, "movsb") == 0) { aNum = 58; }
	else if (strcmp(ptr, "loop") == 0) { aNum = 59; }
	else if (strcmp(ptr, "ins") == 0) { aNum = 60; }
	else if (strcmp(ptr, "std") == 0) { aNum = 61; }
	else if (strcmp(ptr, "cmp") == 0) { aNum = 62; }
	else if (strcmp(ptr, "movzx") == 0) { aNum = 63; }
	else if (strcmp(ptr, "start") == 0) { aNum = 64; }
	else if (strcmp(ptr, "enter") == 0) { aNum = 65; }
	else if (strcmp(ptr, "popf") == 0) { aNum = 66; }
	else if (strcmp(ptr, "retf") == 0) { aNum = 67; }
	else if (strcmp(ptr, "sar") == 0) { aNum = 68; }
	else if (strcmp(ptr, "xchg") == 0) { aNum = 69; }
	else if (strcmp(ptr, "aam") == 0) { aNum = 70; }
	else if (strcmp(ptr, "pand") == 0) { aNum = 71; }
	else { return false; }
	return true;
}

bool translateOpcode2(int& aNum, const char* ptr)
{
	//cout << ptr << endl;
	if (strcmp(ptr, "jz") == 0) { aNum = 0; }
	else if (strcmp(ptr, "jnz") == 0) { aNum = 1; }
	else if (strcmp(ptr, "jb") == 0) { aNum = 2; }
	else if (strcmp(ptr, "jnb") == 0) { aNum = 3; }
	//else if (strcmp(ptr, "je") == 0) { aNum = 4; }
	//else if (strcmp(ptr, "jne") == 0) { aNum = 5; }
	else if (strcmp(ptr, "js") == 0) { aNum = 4; }
	else if (strcmp(ptr, "jns") == 0) { aNum = 5; }
	//else if (strcmp(ptr, "jc") == 0) { aNum = 8; }
	//else if (strcmp(ptr, "jnc") == 0) { aNum = 9; }
	else if (strcmp(ptr, "ja") == 0) { aNum = 6; }
	//else if (strcmp(ptr, "jna") == 0) { aNum = 11; }
	//else if (strcmp(ptr, "jae") == 0) { aNum = 12; }
	else if (strcmp(ptr, "jg") == 0) { aNum = 7; }
	//else if (strcmp(ptr, "jng") == 0) { aNum = 8; }
	else if (strcmp(ptr, "jge") == 0) { aNum = 8; }
	//else if (strcmp(ptr, "jnge") == 0) { aNum = 16; }
	else if (strcmp(ptr, "jbe") == 0) { aNum = 9; }
	//else if (strcmp(ptr, "jnbe") == 0) { aNum = 11; }
	else if (strcmp(ptr, "jl") == 0) { aNum = 10; }
	//else if (strcmp(ptr, "jnl") == 0) { aNum = 13; }
	else if (strcmp(ptr, "jle") == 0) { aNum = 11; }
	//else if (strcmp(ptr, "jnle") == 0) { aNum = 22; }
	//else if (strcmp(ptr, "jp") == 0) { aNum = 23; }
	else if (strcmp(ptr, "jnp") == 0) { aNum = 12; }
	//else if (strcmp(ptr, "jpe") == 0) { aNum = 25; }
	//else if (strcmp(ptr, "jnpo") == 0) { aNum = 26; }
	else if (strcmp(ptr, "jmp") == 0) { aNum = 13; }
	else if (strcmp(ptr, "rep") == 0) { aNum = 14; }
	else if (strcmp(ptr, "mov") == 0) { aNum = 15; }
	else if (strcmp(ptr, "pop") == 0) { aNum = 16; }
	else if (strcmp(ptr, "add") == 0) { aNum = 17; }
	else if (strcmp(ptr, "retn") == 0) { aNum = 18; }
	else if (strcmp(ptr, "push") == 0) { aNum = 19; }
	else if (strcmp(ptr, "rcl") == 0) { aNum = 20; }
	else if (strcmp(ptr, "call") == 0) { aNum = 21; }
	else if (strcmp(ptr, "popa") == 0) { aNum = 22; }
	else if (strcmp(ptr, "lea") == 0) { aNum = 23; }
	else if (strcmp(ptr, "div") == 0) { aNum = 24; }
	else if (strcmp(ptr, "cld") == 0) { aNum = 25; }
	else if (strcmp(ptr, "adc") == 0) { aNum = 26; }
	else if (strcmp(ptr, "shl") == 0) { aNum = 27; }
	else if (strcmp(ptr, "ror") == 0) { aNum = 28; }
	else if (strcmp(ptr, "inc") == 0) { aNum = 29; }
	else if (strcmp(ptr, "or") == 0) { aNum = 30; }
	else if (strcmp(ptr, "test") == 0) { aNum = 31; }
	else if (strcmp(ptr, "shr") == 0) { aNum = 32; }
	else if (strcmp(ptr, "sbb") == 0) { aNum = 33; }
	//else if (strcmp(ptr, "bound") == 0) { aNum = 48; }
	else if (strcmp(ptr, "sub") == 0) { aNum = 34; }
	else if (strcmp(ptr, "xor") == 0) { aNum = 35; }
	else if (strcmp(ptr, "pusha") == 0) { aNum = 36; }
	else if (strcmp(ptr, "dec") == 0) { aNum = 37; }
	else if (strcmp(ptr, "and") == 0) { aNum = 38; }
	else if (strcmp(ptr, "fidiv") == 0) { aNum = 39; }
	else if (strcmp(ptr, "not") == 0) { aNum = 40; }
	else if (strcmp(ptr, "neg") == 0) { aNum = 41; }
	else if (strcmp(ptr, "imul") == 0) { aNum = 42; }
	else if (strcmp(ptr, "movsb") == 0) { aNum = 43; }
	else if (strcmp(ptr, "loop") == 0) { aNum = 44; }
	//else if (strcmp(ptr, "ins") == 0) { aNum = 60; }
	else if (strcmp(ptr, "std") == 0) { aNum = 45; }
	else if (strcmp(ptr, "cmp") == 0) { aNum = 46; }
	else if (strcmp(ptr, "movzx") == 0) { aNum = 47; }
	else if (strcmp(ptr, "start") == 0) { aNum = 48; }
	//else if (strcmp(ptr, "enter") == 0) { aNum = 65; }
	else if (strcmp(ptr, "popf") == 0) { aNum = 49; }
	else if (strcmp(ptr, "retf") == 0) { aNum = 50; }
	else if (strcmp(ptr, "sar") == 0) { aNum = 51; }
	else if (strcmp(ptr, "xchg") == 0) { aNum = 52; }
	//else if (strcmp(ptr, "aam") == 0) { aNum = 53; }
	//else if (strcmp(ptr, "pand") == 0) { aNum = 71; }
	else { return false; }
	return true;
}

bool translateOpcode3(int& aNum, const char* ptr)
{
	//cout << ptr << endl;
	if (strcmp(ptr, "jz") == 0) { aNum = 0; }
	else if (strcmp(ptr, "jnz") == 0) { aNum = 1; }
	else if (strcmp(ptr, "jb") == 0) { aNum = 2; }
	else if (strcmp(ptr, "jnb") == 0) { aNum = 3; }
	//else if (strcmp(ptr, "je") == 0) { aNum = 4; }
	//else if (strcmp(ptr, "jne") == 0) { aNum = 5; }
	//else if (strcmp(ptr, "js") == 0) { aNum = 4; }
	//else if (strcmp(ptr, "jns") == 0) { aNum = 5; }
	//else if (strcmp(ptr, "jc") == 0) { aNum = 8; }
	//else if (strcmp(ptr, "jnc") == 0) { aNum = 9; }
	else if (strcmp(ptr, "ja") == 0) { aNum = 4; }
	//else if (strcmp(ptr, "jna") == 0) { aNum = 11; }
	//else if (strcmp(ptr, "jae") == 0) { aNum = 12; }
	else if (strcmp(ptr, "jg") == 0) { aNum = 5; }
	//else if (strcmp(ptr, "jng") == 0) { aNum = 8; }
	else if (strcmp(ptr, "jge") == 0) { aNum = 6; }
	//else if (strcmp(ptr, "jnge") == 0) { aNum = 16; }
	else if (strcmp(ptr, "jbe") == 0) { aNum = 7; }
	//else if (strcmp(ptr, "jnbe") == 0) { aNum = 11; }
	else if (strcmp(ptr, "jl") == 0) { aNum = 8; }
	//else if (strcmp(ptr, "jnl") == 0) { aNum = 13; }
	else if (strcmp(ptr, "jle") == 0) { aNum = 9; }
	//else if (strcmp(ptr, "jnle") == 0) { aNum = 22; }
	//else if (strcmp(ptr, "jp") == 0) { aNum = 23; }
	//else if (strcmp(ptr, "jnp") == 0) { aNum = 12; }
	//else if (strcmp(ptr, "jpe") == 0) { aNum = 25; }
	//else if (strcmp(ptr, "jnpo") == 0) { aNum = 26; }
	else if (strcmp(ptr, "jmp") == 0) { aNum = 10; }
	else if (strcmp(ptr, "rep") == 0) { aNum = 11; }
	else if (strcmp(ptr, "mov") == 0) { aNum = 12; }
	else if (strcmp(ptr, "pop") == 0) { aNum = 13; }
	else if (strcmp(ptr, "add") == 0) { aNum = 14; }
	else if (strcmp(ptr, "retn") == 0) { aNum = 15; }
	else if (strcmp(ptr, "push") == 0) { aNum = 16; }
	else if (strcmp(ptr, "rcl") == 0) { aNum = 17; }
	else if (strcmp(ptr, "call") == 0) { aNum = 18; }
	else if (strcmp(ptr, "popa") == 0) { aNum = 19; }
	else if (strcmp(ptr, "lea") == 0) { aNum = 20; }
	else if (strcmp(ptr, "div") == 0) { aNum = 21; }
	else if (strcmp(ptr, "cld") == 0) { aNum = 22; }
	else if (strcmp(ptr, "adc") == 0) { aNum = 23; }
	else if (strcmp(ptr, "shl") == 0) { aNum = 24; }
	else if (strcmp(ptr, "ror") == 0) { aNum = 25; }
	else if (strcmp(ptr, "inc") == 0) { aNum = 26; }
	else if (strcmp(ptr, "or") == 0) { aNum = 27; }
	else if (strcmp(ptr, "test") == 0) { aNum = 28; }
	else if (strcmp(ptr, "shr") == 0) { aNum = 29; }
	else if (strcmp(ptr, "sbb") == 0) { aNum = 30; }
	//else if (strcmp(ptr, "bound") == 0) { aNum = 48; }
	else if (strcmp(ptr, "sub") == 0) { aNum = 31; }
	else if (strcmp(ptr, "xor") == 0) { aNum = 32; }
	else if (strcmp(ptr, "pusha") == 0) { aNum = 33; }
	else if (strcmp(ptr, "dec") == 0) { aNum = 34; }
	else if (strcmp(ptr, "and") == 0) { aNum = 35; }
	//else if (strcmp(ptr, "fidiv") == 0) { aNum = 39; }
	else if (strcmp(ptr, "not") == 0) { aNum = 36; }
	else if (strcmp(ptr, "neg") == 0) { aNum = 37; }
	else if (strcmp(ptr, "imul") == 0) { aNum = 38; }
	else if (strcmp(ptr, "movsb") == 0) { aNum = 39; }
	else if (strcmp(ptr, "loop") == 0) { aNum = 40; }
	//else if (strcmp(ptr, "ins") == 0) { aNum = 60; }
	//else if (strcmp(ptr, "std") == 0) { aNum = 45; }
	else if (strcmp(ptr, "cmp") == 0) { aNum = 41; }
	else if (strcmp(ptr, "movzx") == 0) { aNum = 42; }
	else if (strcmp(ptr, "start") == 0) { aNum = 43; }
	//else if (strcmp(ptr, "enter") == 0) { aNum = 65; }
	else if (strcmp(ptr, "popf") == 0) { aNum = 44; }
	else if (strcmp(ptr, "retf") == 0) { aNum = 45; }
	else if (strcmp(ptr, "sar") == 0) { aNum = 46; }
	else if (strcmp(ptr, "xchg") == 0) { aNum = 47; }
	//else if (strcmp(ptr, "aam") == 0) { aNum = 53; }
	//else if (strcmp(ptr, "pand") == 0) { aNum = 71; }
	else { return false; }
	return true;
}
double computeLog(int T, HmmModel* aModel)
{
	double logProb = 0;
	for (int i = 0; i < T ; i++) { logProb = logProb + log((aModel->getScale())[i]); }
	logProb = -logProb;
	return logProb;
}