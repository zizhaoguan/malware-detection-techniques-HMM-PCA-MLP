#ifndef HMMMODEL_H
#define HMMMODEL_H

#include <iostream>
#include <ctime>
#include <fstream>
#include <String>
#include <iomanip>
#include <vector>

using namespace std;

class HmmModel
{
private:
	int N;  //number of state
	int M;  //number of observation

	double piMatrix[2];
	double AMatrix[2][2] ;
	//double BMatrix[2][72];
	double BMatrix[2][53];
	double denom;
	double numer;
	int T; //How many times or observations are going to be tested
	int* opcodeSequence = NULL;

	double* scale = NULL;
	double** alpha = NULL; //the probability up to time t at each state
	double** beta = NULL; //the probability after time t at each state
	double** gammas = NULL;
	double*** digammas = NULL;
	int iter = 0;
	double diff;
	double oldLogProb = -1000000;
	double logProbability;
	bool goodModel = false;

	vector<int> badOpCodeSet;
	
public:

	HmmModel()
	{
		N = 2;
		//M = 72;
		M = 53;
		int i, j;
		for (i = 0; i < N; i++) { piMatrix[i] = 0; }
		for (i = 0; i < N; i++)
		{
			for (j = 0; j < N; j++) { AMatrix[i][j] = 0; }
		}
		for (i = 0; i < N; i++)
		{
			for (j = 0; j < M; j++) { AMatrix[i][j] = 0; }
		}
	}
	void initializeModel(int* opcodePtr) //initialize the A,B matrix and дл
	{
		opcodeSequence = opcodePtr;
		int num = 100;
		srand((unsigned)time(0));
		for (int i = 0; i <N ; i++) //set data to дл
		{
			piMatrix[i] = (double)(rand() % num);
		}
		for (int i = 0; i < N ; i++) // set data to A matrix
		{
			for (int j = 0; j < N; j++) { AMatrix[i][j] = (double)(rand() % num); }
		}
		for (int i = 0; i < N ; i++) // set data to B matrix
		{
			for (int j = 0; j < M; j++) { BMatrix[i][j] = (double)(rand() % num); }
		}
		normalizePi();
		normalizeA();
		normalizeB();
	}
	
	void normalizePi()
	{
		double piSum = 0;
		int i;
		for (i = 0; i < N ; i++) { piSum += piMatrix[i]; }
		for (i = 0; i < N ; i++) { piMatrix[i] = piMatrix[i] / piSum; }
	}
	void normalizeA()
	{
		int i, j;
		double ASum;
		for (i = 0; i <= N; i++)
		{
			ASum = 0.00000;
			for (j = 0; j < N ; j++) { ASum += AMatrix[i][j]; }
			for (j = 0; j < N ; j++) { AMatrix[i][j] = AMatrix[i][j] / ASum; }
		}
	}
	void normalizeB()
	{
		int i, j;
		double BSum;
		for (i = 0; i < N ; i++)
		{
			BSum = 0.00000;
			for (j = 0; j < M ; j++) { BSum += BMatrix[i][j]; }
			for (j = 0; j <= M - 1; j++) { BMatrix[i][j] = BMatrix[i][j] / BSum; }
		}
	}
	void printPi()
	{
		cout << "дл= (";
		for (int i = 0; i < N ; i++) { cout << piMatrix[i] << "  "; }
		cout << ")" << '\n';
	}
	void printAMatrixWFile(int state)
	{
		fstream myFile;
		if (state == 0) { myFile.open("initial A Matrix.txt", ios::out); }
		else { myFile.open("final A Matrix.txt", ios::out); }
		cout << "A =" << '\n';
		myFile << "A =" << '\n';
		for (int i = 0; i < N ; i++)
		{
			cout << "(";
			myFile << "(";
			for (int j = 0; j < N ; j++)
			{
				cout << AMatrix[i][j] << "  ";
				myFile << AMatrix[i][j] << "  ";
			}
			cout << ")" << endl;
			myFile << ")" << endl;
		}
		myFile.close();
	}

	void printBMatrixWFile(int state)
	{
		fstream myFile;
		if (state == 0) { myFile.open("initial B Matrix.txt", ios::out); }
		else { myFile.open("final B Matrix.txt", ios::out); }

		cout << "B =" << '\n';

		for (int j = 0; j < M ; j++)
		{
			cout <<setw(8)<< left<< returnOpcode2(j)<<" : (";
			myFile << setw(12) << left << returnOpcode2(j) << " : (";
			for (int i = 0; i <= N - 1; i++)
			{
				cout << setw(12) << right << BMatrix[i][j] << "  ";
				myFile << setw(12) << right << BMatrix[i][j] << "  ";
			}
			cout << ")" << endl;
			myFile << ")" << endl;
		}
		//myFile.close();
	}
	
	string returnOpcode(int num)
	{
		string opcode;
		if (num == 0) { opcode = "jz"; }
		else if (num == 1 ) { opcode = "jnz"; }
		else if (num == 2 ) { opcode = "jb"; }
		else if (num == 3 ) { opcode = "jnb"; }
		else if (num == 4 ) { opcode = "je"; }
		else if (num == 5 ) { opcode = "jne"; }
		else if (num == 6 ) { opcode = "js"; }
		else if (num == 7 ) { opcode = "jns"; }
		else if (num == 8 ) { opcode = "jc"; }
		else if (num == 9 ) { opcode = "jnc"; }
		else if (num == 10 ) { opcode = "ja"; }
		else if (num == 11 ) { opcode = "jna"; }
		else if (num == 12 ) { opcode = "jae"; }
		else if (num == 13 ) { opcode = "jg"; }
		else if (num == 14 ) { opcode = "jng"; }
		else if (num == 15 ) { opcode = "jge"; }
		else if (num == 16 ) { opcode = "jnge"; }
		else if (num == 17 ) { opcode = "jbe"; }
		else if (num == 18 ) { opcode = "jnbe"; }
		else if (num == 19 ) { opcode = "jl"; }
		else if (num == 20 ) { opcode = "jnl"; }
		else if (num == 21 ) { opcode = "jle"; }
		else if (num == 22 ) { opcode = "jnle"; }
		else if (num == 23 ) { opcode = "jp" ; }
		else if (num == 24 ) { opcode = "jnp" ; }
		else if (num == 25 ) { opcode = "jpe" ; }
		else if (num == 26 ) { opcode = "jnpo" ; }
		else if (num == 27 ) { opcode = "jmp"; }
		else if (num == 28 ) { opcode = "rep"; }
		else if (num == 29 ) { opcode = "mov"; }
		else if (num == 30 ) { opcode = "pop"; }
		else if (num == 31 ) { opcode = "add"; }
		else if (num == 32 ) { opcode = "retn"; }
		else if (num == 33 ) { opcode = "push"; }
		else if (num == 34 ) { opcode = "rcl"; }
		else if (num == 35 ) { opcode = "call"; }
		else if (num == 36 ) { opcode = "popa"; }
		else if (num == 37 ) { opcode = "lea"; }
		else if (num == 38 ) { opcode = "div"; }
		else if (num == 39 ) { opcode = "cld"; }
		else if (num == 40 ) { opcode = "adc"; }
		else if (num == 41 ) { opcode = "shl"; }
		else if (num == 42 ) { opcode = "ror"; }
		else if (num == 43 ) { opcode = "inc"; }
		else if (num == 44 ) { opcode = "or"; }
		else if (num == 45 ) { opcode = "test"; }
		else if (num == 46 ) { opcode = "shr"; }
		else if (num == 47 ) { opcode = "sbb"; }
		else if (num == 48 ) { opcode = "bound"; }
		else if (num == 49 ) { opcode = "sub"; }
		else if (num == 50 ) { opcode = "xor"; }
		else if (num == 51 ) { opcode = "pusha"; }
		else if (num == 52 ) { opcode = "dec"; }
		else if (num == 53 ) { opcode = "and"; }
		else if (num == 54 ) { opcode = "fidiv"; }
		else if (num == 55 ) { opcode = "not"; }
		else if (num == 56 ) { opcode = "neg"; }
		else if (num == 57 ) { opcode = "imul"; }
		else if (num == 58 ) { opcode = "movsb"; }
		else if (num == 59 ) { opcode = "loop"; }
		else if (num == 60 ) { opcode = "ins"; }
		else if (num == 61 ) { opcode = "std"; }
		else if (num == 62 ) { opcode = "cmp"; }
		else if (num == 63 ) { opcode = "movzx"; }
		else if (num == 64 ) { opcode = "start"; }
		else if (num == 65 ) { opcode = "enter"; }
		else if (num == 66 ) { opcode = "popf"; }
		else if (num == 67 ) { opcode = "retf"; }
		else if (num == 68 ) { opcode = "sar"; }
		else if (num == 69 ) { opcode = "xchg"; }
		else if (num == 70 ) { opcode = "aam"; }
		else if (num == 71 ) { opcode = "pand"; }
		return opcode;
	}

	string returnOpcode2(int num)
	{
		string opcode;
		if (num == 0) { opcode = "jz"; }
		else if (num == 1) { opcode = "jnz"; }
		else if (num == 2) { opcode = "jb"; }
		else if (num == 3) { opcode = "jnb"; }
		//else if (num == 4) { opcode = "je"; }
		//else if (num == 5) { opcode = "jne"; }
		else if (num == 4) { opcode = "js"; }
		else if (num == 5) { opcode = "jns"; }
		//else if (num == 8) { opcode = "jc"; }
		//else if (num == 9) { opcode = "jnc"; }
		else if (num == 6) { opcode = "ja"; }
		//else if (num == 11) { opcode = "jna"; }
		//else if (num == 12) { opcode = "jae"; }
		else if (num == 7) { opcode = "jg"; }
		//else if (num == 8) { opcode = "jng"; }
		else if (num == 8) { opcode = "jge"; }
		//else if (num == 16) { opcode = "jnge"; }
		else if (num == 9) { opcode = "jbe"; }
		//else if (num == 11) { opcode = "jnbe"; }
		else if (num == 10) { opcode = "jl"; }
		//else if (num == 13) { opcode = "jnl"; }
		else if (num == 11) { opcode = "jle"; }
		//else if (num == 22) { opcode = "jnle"; }
		//else if (num == 23) { opcode = "jp"; }
		else if (num == 12) { opcode = "jnp"; }
		//else if (num == 25) { opcode = "jpe"; }
		//else if (num == 26) { opcode = "jnpo"; }
		else if (num == 13) { opcode = "jmp"; }
		else if (num == 14) { opcode = "rep"; }
		else if (num == 15) { opcode = "mov"; }
		else if (num == 16) { opcode = "pop"; }
		else if (num == 17) { opcode = "add"; }
		else if (num == 18) { opcode = "retn"; }
		else if (num == 19) { opcode = "push"; }
		else if (num == 20) { opcode = "rcl"; }
		else if (num == 21) { opcode = "call"; }
		else if (num == 22) { opcode = "popa"; }
		else if (num == 23) { opcode = "lea"; }
		else if (num == 24) { opcode = "div"; }
		else if (num == 25) { opcode = "cld"; }
		else if (num == 26) { opcode = "adc"; }
		else if (num == 27) { opcode = "shl"; }
		else if (num == 28) { opcode = "ror"; }
		else if (num == 29) { opcode = "inc"; }
		else if (num == 30) { opcode = "or"; }
		else if (num == 31) { opcode = "test"; }
		else if (num == 32) { opcode = "shr"; }
		else if (num == 33) { opcode = "sbb"; }
		//else if (num == 48) { opcode = "bound"; }
		else if (num == 34) { opcode = "sub"; }
		else if (num == 35) { opcode = "xor"; }
		else if (num == 36) { opcode = "pusha"; }
		else if (num == 37) { opcode = "dec"; }
		else if (num == 38) { opcode = "and"; }
		else if (num == 39) { opcode = "fidiv"; }
		else if (num == 40) { opcode = "not"; }
		else if (num == 41) { opcode = "neg"; }
		else if (num == 42) { opcode = "imul"; }
		else if (num == 43) { opcode = "movsb"; }
		else if (num == 44) { opcode = "loop"; }
		//else if (num == 60) { opcode = "ins"; }
		else if (num == 45) { opcode = "std"; }
		else if (num == 46) { opcode = "cmp"; }
		else if (num == 47) { opcode = "movzx"; }
		else if (num == 48) { opcode = "start"; }
		//else if (num == 65) { opcode = "enter"; }
		else if (num == 49) { opcode = "popf"; }
		else if (num == 50) { opcode = "retf"; }
		else if (num == 51) { opcode = "sar"; }
		else if (num == 52) { opcode = "xchg"; }
		//else if (num == 53) { opcode = "aam"; }
		//else if (num == 71) { opcode = "pand"; }
		return opcode;
	}

	string returnOpcode3(int num)
	{
		string opcode;
		if (num == 0) { opcode = "jz"; }
		else if (num == 1) { opcode = "jnz"; }
		else if (num == 2) { opcode = "jb"; }
		else if (num == 3) { opcode = "jnb"; }
		//else if (num == 4) { opcode = "je"; }
		//else if (num == 5) { opcode = "jne"; }
		//else if (num == 4) { opcode = "js"; }
		//else if (num == 5) { opcode = "jns"; }
		//else if (num == 8) { opcode = "jc"; }
		//else if (num == 9) { opcode = "jnc"; }
		else if (num == 4) { opcode = "ja"; }
		//else if (num == 11) { opcode = "jna"; }
		//else if (num == 12) { opcode = "jae"; }
		else if (num == 5) { opcode = "jg"; }
		//else if (num == 8) { opcode = "jng"; }
		else if (num == 6) { opcode = "jge"; }
		//else if (num == 16) { opcode = "jnge"; }
		else if (num == 7) { opcode = "jbe"; }
		//else if (num == 11) { opcode = "jnbe"; }
		else if (num == 8) { opcode = "jl"; }
		//else if (num == 13) { opcode = "jnl"; }
		else if (num == 9) { opcode = "jle"; }
		//else if (num == 22) { opcode = "jnle"; }
		//else if (num == 23) { opcode = "jp"; }
		//else if (num == 12) { opcode = "jnp"; }
		//else if (num == 25) { opcode = "jpe"; }
		//else if (num == 26) { opcode = "jnpo"; }
		else if (num == 10) { opcode = "jmp"; }
		else if (num == 11) { opcode = "rep"; }
		else if (num == 12) { opcode = "mov"; }
		else if (num == 13) { opcode = "pop"; }
		else if (num == 14) { opcode = "add"; }
		else if (num == 15) { opcode = "retn"; }
		else if (num == 16) { opcode = "push"; }
		else if (num == 17) { opcode = "rcl"; }
		else if (num == 18) { opcode = "call"; }
		else if (num == 19) { opcode = "popa"; }
		else if (num == 20) { opcode = "lea"; }
		else if (num == 21) { opcode = "div"; }
		else if (num == 22) { opcode = "cld"; }
		else if (num == 23) { opcode = "adc"; }
		else if (num == 24) { opcode = "shl"; }
		else if (num == 25) { opcode = "ror"; }
		else if (num == 26) { opcode = "inc"; }
		else if (num == 27) { opcode = "or"; }
		else if (num == 28) { opcode = "test"; }
		else if (num == 29) { opcode = "shr"; }
		else if (num == 30) { opcode = "sbb"; }
		//else if (num == 48) { opcode = "bound"; }
		else if (num == 31) { opcode = "sub"; }
		else if (num == 32) { opcode = "xor"; }
		else if (num == 33) { opcode = "pusha"; }
		else if (num == 34) { opcode = "dec"; }
		else if (num == 35) { opcode = "and"; }
		//else if (num == 39) { opcode = "fidiv"; }
		else if (num == 36) { opcode = "not"; }
		else if (num == 37) { opcode = "neg"; }
		else if (num == 38) { opcode = "imul"; }
		else if (num == 39) { opcode = "movsb"; }
		else if (num == 40) { opcode = "loop"; }
		//else if (num == 60) { opcode = "ins"; }
		//else if (num == 45) { opcode = "std"; }
		else if (num == 41) { opcode = "cmp"; }
		else if (num == 42) { opcode = "movzx"; }
		else if (num == 43) { opcode = "start"; }
		//else if (num == 65) { opcode = "enter"; }
		else if (num == 44) { opcode = "popf"; }
		else if (num == 45) { opcode = "retf"; }
		else if (num == 46) { opcode = "sar"; }
		else if (num == 47) { opcode = "xchg"; }
		//else if (num == 53) { opcode = "aam"; }
		//else if (num == 71) { opcode = "pand"; }
		return opcode;
	}

	void printRowSum()
	{
		double sum;
		for (int i = 0; i < N ; i++)
		{
			sum = 0;
			cout << "sum of " << i + 1 << " row of A matrix:" << endl;
			for (int j = 0; j < N ; j++) { sum += AMatrix[i][j]; }
			cout << sum << endl;
		}
		for (int i = 0; i < N ; i++)
		{
			sum = 0;
			cout << "sum of " << i + 1 << " row of B matrix:" << endl;
			for (int j = 0; j <= M - 1; j++) { sum += BMatrix[i][j]; }
			cout << sum << endl;
		}
	}
	//initialize the scale, alpha, beta, gammas and digammas
	void setData(int time)
	{
		T = time;
		scale = new double[T];
		alpha = new double* [T];//allocate space of T pointers that point to double, return the addr of the pointer pointing to those double pointer to alpha
		int t;
		for (t = 0; t < T; t++) { alpha[t] = new double[N]; }

		beta = new double* [T];
		for (t = 0; t < T; t++) { beta[t] = new double[N]; }

		gammas = new double* [T];
		for (t = 0; t < T ; t++) { gammas[t] = new double[N]; }

		digammas = new double** [T];//allocate space of T pointers that point to the pointer of double, return the address of the first pointer to digammas
		for (t = 0; t < T; t++)    //as the pointer digammas has, it (digammas) point to T pointers that every pointer point to some other pointers that point to double
		{
			digammas[t] = new double* [N];
			for (int i = 0; i <= N - 1; i++) { digammas[t][i] = new double[N]; }
		}
	}
	void freeAllPtr()
	{
		delete scale;
		scale = NULL;
		int t, i ;
		for (t = 0; t < T ; t++)
		{
			delete alpha[t];
			alpha[t] = NULL;
		}
		delete alpha;
		alpha = NULL;

		for (t = 0; t < T ; t++)
		{
			delete gammas[t];
			gammas[t] = NULL;
		}
		delete gammas;
		gammas = NULL;

		for (t = 0; t < T ; t++)
		{
			for ( i = 0; i < N ; i++)
			{
				delete digammas[t][i];
				digammas[t][i] = NULL;
			}
			delete digammas[t];
			digammas[t] = NULL;
		}
		delete digammas;
		digammas = NULL;
	}

	void computeAlphaPass(int* opcodePtr)
	{
		int i, j, t;
		scale[0] = 0;
		for (i = 0; i < N ; i++)
		{
			alpha[0][i] = piMatrix[i] * (BMatrix[i][opcodePtr[0]]);
			scale[0] += alpha[0][i];
		}
		scale[0] = ((double)1.0 / scale[0]);
		for (i = 0; i < N ; i++)
		{
			alpha[0][i] = alpha[0][i] * scale[0];
		}
		for (t = 1; t < T; t++) //computer alpha[t][i]
		{
			scale[t] = 0;
			for (i = 0; i < N; i++)
			{
				alpha[t][i] = 0;
				for (j = 0; j < N; j++) { alpha[t][i] = alpha[t][i] + alpha[t - 1][j] * AMatrix[j][i]; }
				alpha[t][i] = alpha[t][i] * (BMatrix[i][opcodePtr[t]]);
				scale[t] += alpha[t][i];
			}
			scale[t] = ((double)1.0 / scale[t]);

			for (i = 0; i < N; i++) { alpha[t][i] = scale[t] * alpha[t][i]; }
		}
	}
	void computeBetaPass(int* opcodePtr)
	{
		int i, j, t;
		for (i = 0; i < N; i++) {beta[T - 1][i] = scale[T - 1]; }
		for (t = T - 2; t >= 0; t--) //computer beta pass
		{
			for (i = 0; i < N ; i++)
			{
				beta[t][i]=0;
				for (j = 0; j < N ; j++)
				{
					beta[t][i] = beta[t][i]+ AMatrix[i][j] * (BMatrix[j][opcodePtr[t + 1]]) * beta[t + 1][j];
				}
				beta[t][i] = scale[t] * beta[t][i];
			}
		}
	}
	void computeGammas(int* opcodePtr)
	{
		int i, j, t;
		/*double gammasTemp;
		double alphaTemp;*/
		for (t = 0; t <= T - 2; t++)
		{
			denom = 0;
			for (i = 0; i <= N - 1; i++)
			{
				//alphaTemp = alpha[t][i];
				for (j = 0; j <= N - 1; j++)
				{
					denom = denom + alpha[t][i] * AMatrix[i][j] * (BMatrix[j][opcodePtr[t + 1]]) * beta[t + 1][j];
				}
			}
			for (i = 0; i <= N - 1; i++)
			{
				//gammasTemp = 0;  //in the j loop, there is no changing of alpha[t][i], because it will not change the t and i in j loop
				//alphaTemp = alpha[t][i];
				gammas[t][i] = 0;
				for (j = 0; j < N ; j++)
				{
					digammas[t][i][j] = (alpha[t][i] * AMatrix[i][j] * (BMatrix[j][opcodePtr[t + 1]]) * beta[t + 1][j] / denom);
					gammas[t][i] = gammas[t][i] + digammas[t][i][j];
				}
			}
		}

		denom = 0; //Special case for gammas[T-1][i]
		for (i = 0; i < N ; i++) { denom = denom + alpha[T - 1][i]; }
		for (i = 0; i < N ; i++) { gammas[T - 1][i] = alpha[T - 1][i] / denom; }
	}
	void reestimate(int* opcodePtr)
	{
		int i, j, t;
		for (i = 0; i < N; i++) { piMatrix[i] = gammas[0][i]; } //re-estimate pi
		for (i = 0; i < N ; i++)   //re-estimate A
		{
			for (j = 0; j < N ; j++)
			{
				numer = 0;
				denom = 0;
				for (t = 0; t <= T - 2; t++)
				{
					numer = numer + digammas[t][i][j];
					denom = denom + gammas[t][i];
				}
				AMatrix[i][j] = numer / denom;
			}
		}
		for (i = 0; i < N ; i++)  //re-estimate B
		{
			for (j = 0; j < M ; j++)
			{
				numer = 0;
				denom = 0;
				for (t = 0; t <= T - 1; t++)
				{
					if (opcodePtr[t] == j) { numer = numer + gammas[t][i]; }
					denom = denom + gammas[t][i];
				}
				BMatrix[i][j] = numer / denom;
			}
		}
	}
	int getT() { return T; }
	double* getScale() { return scale; }
	void addIter(int num) { iter = iter + num; }
	int getIter() { return iter; }
	void setOldProlog(double num) { oldLogProb = num; }
	double getOldProlog() { return oldLogProb; }
	void setNewProlog(double num) { logProbability = num; }
	double getNewProlog() { return logProbability; }
	void setDiff(double num) { diff = num; }
	double getDiff() { return diff; }
	bool checkIfGoodModel() { return goodModel; }
	void setGoodModel(bool condition) { goodModel = condition; }

	double scoreTestSet(int* opcodePtr)
	{
		int i, j, t;
		scale[0] = 0.0;
		
		for (i = 0; i < N; i++)
		{
			alpha[0][i] = piMatrix[i] * (BMatrix[i][opcodePtr[0]]);
			scale[0] += alpha[0][i];
		}
		scale[0] = (1 / scale[0]);
		for (i = 0; i < N; i++)
		{
			alpha[0][i] = alpha[0][i] * scale[0];
		}
		for (t = 1; t < T; t++) //computer alpha[t][i]
		{
			cout << "t = " << t << endl;
			scale[t] = 0;
			for (i = 0; i < N; i++)
			{
				alpha[t][i] = 0;
				for (j = 0; j < N; j++) { alpha[t][i] = alpha[t][i] + alpha[t - 1][j] * AMatrix[j][i];}
				alpha[t][i] = alpha[t][i] * (BMatrix[i][opcodePtr[t]]);
				scale[t] += alpha[t][i]; //scale become 0 when alpha[t][0]=0 and alpha[t][1]=0
				//cout << "alpha " << alpha[t][i] << endl;
			}
			scale[t] = ((double)1.0 / scale[t]);
			cout << "scale: " << scale[t] << endl;
			for (i = 0; i < N; i++) { alpha[t][i] = scale[t] * alpha[t][i]; }
		}
		/*
		double score = 1;
		for (t = 0; t <= T - 1; t++) { score = score * scale[t]; }
		score = 1 / score;
		return score;*/
		double score = 0;
		for (i = 0; i < N; i++)
		{
			score += alpha[T - 1][i];
		}
		return score;
	}
	double* getPi() { return piMatrix; }
	
	double* getA(int i) { return AMatrix[i]; } //return a pointer that point to 2 double;												
	double* getB(int i) { return BMatrix[i]; } //such as B is a pointer that pointer to 2 pointers and each of these 2 pointers point to 72 doubles,
											   //but for here, we are not return the B pointer, we return that 2 pointers the B pointer point to.
											   //But we return 1 at a time, when i=0; we return BMatrix[0] pointer that point to 72 doubles, another time we return BMatrix[1] when i=1,
											   //and it also points to 72 doubles

	//copy the pi matrix from result of training model
	void copyPi(HmmModel* training)
	{
		for (int i = 0; i < N; i++) { piMatrix[i] = (training->getPi())[i]; }
	}

	//copy the A matrix from result of training model
	void copyA(HmmModel* training)
	{
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < N; j++) { AMatrix[i][j] = (training->getA(i))[j]; }
		}
	}

	//copy the B matrix from result of training model
	void copyB(HmmModel* training)
	{
		for(int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++) { BMatrix[i][j] = (training->getB(i))[j]; }
		} 
	}
	void BMatrixAddNum(double num)
	{
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++) { BMatrix[i][j] =BMatrix[i][j] + num; }
		}
		normalizeB();
	}
	int* getOpcodeSequence() { return opcodeSequence; }
	void checekBadOpCode()
	{
		bool zero;
		for (int j = 0; j < M; j++)
		{
			zero = true;
			for (int i = 0; i < N; i++)
			{
				if (BMatrix[i][j] != 0) { zero = false; }
			}
			if (zero == true) { badOpCodeSet.push_back(j); }
		}
		for (int i = 0; i < badOpCodeSet.size(); i++) { cout << "bad opcode: " << badOpCodeSet[i] << endl; }
	}
};

#endif // !HMMMODEL_H
#pragma once
